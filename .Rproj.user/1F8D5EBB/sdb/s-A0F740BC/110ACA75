{
    "collab_server" : "",
    "contents" : "#'@title K-mean algorithm for clustering and alignment of functional data\n#'\n#'@description kmap jointly performs clustering and alignment of a functional dataset\n#'(multidimensional or unidimensional functions). To run kmap function with different\n#'numbers of clusters and/or different alignment methods see the input options.\n#'\n#'@usage res<-kmap(  x, y,  y1, n_clust,warping_method, center_method,similarity_method,\n#'optim_method, seeds, span, delta, d_max, s_max, n_out, toll, fence,\n#' iter_max,show_iter, check_total_similarity)\n#'\n#'@param x numeric matrix [\\emph{n.func} X \\emph{grid.size}] or vector [\\emph{grid.size}]:\n#'     the abscissa values where each function is evaluated. \\emph{n.func}: number\n#'     of functions in the dataset. \\emph{grid.size}: maximal number of abscissa values\n#'     where each function is evaluated. The abscissa points may be unevenly spaced and\n#'     they may differ from function to function. \\code{x} can also be a vector of length\n#'     \\emph{grid.size}. In this case, \\code{x} will be used as abscissa grid for all\n#'     functions.Furthermore if the grid's size differs from one function to another the\n#'     matrix must be completed with NA values.The parameter \\code{x} must be\n#'     provided.\n#'\n#'@param y numeric matrix [\\emph{n.func} X \\emph{grid.size}] or array [\\emph{n.func} X \\emph{grid.size}\n#'         X \\emph{d}]: evaluations of the set of original functions on the abscissa grid\n#'         \\code{x}. \\emph{n.func}: number of functions in the dataset. \\emph{grid.size}:\n#'         maximal number of abscissa values where each function is evaluated. \\emph{d}:\n#'         (only if the sample is multidimensional) number of function components, i.e.\n#'          each function is a \\emph{d}-dimensional curve. The parameter \\code{y} must be\n#'           provided.\n#'\n#' @param seeds numeric vector [n.clust] indexes of the functions to be used as initial centers.\n#'               In the case where the values of seeds are not provided, they are randomly\n#'                chosen among the \\emph{n.func} original functions.If seeds=NULL all the\n#'                centers are randomly chosen. Default value of seeds is NULL.\n#'\n#'@param n_clust scalar: required number of clusters. Default value is 1. Note that if\n#'               n.clust=1 kma performs only alignment without clustering.\n#'\n#' @param warping_method character: type of alignment required. The implemented options\n#'                       are: \"affine\", \"dialation\", \"shift\" and \"noalign\". If\n#'                       warping.method='noalign' kma performs only clustering (without\n#'                        alignment). If warping.method='affine' kma performs alignment\n#'                       (and possibly clustering) of functions using linear affine\n#'                       transformation as warping functions, i.e., x.final = dilation*x + shift.\n#'                        If warping.method='shift' kma allows only shift, i.e.,\n#'                        x.final = x + shift. If warping.method='dilation' kma allows only\n#'                        dilation, i.e., x.final = dilation*x. Default value is 'affine'.\n#'\n#'@param center_method character: type of clustering method to be used.\n#'                     Possible choices are: 'mean','medoid' and 'pseudomedoid'.\n#'                     Default value is 'mean'.\n#'\n#'@param similarity_method character: required similarity measure. Possible choices are:\n#'                         'pearson','l2'. Default value is 'pearson'.\n#'\n#'@param optim_method character: optimization method chosen to solve the minimization\n#'                    problems at each iteration. Possible choices are: 'bobyqa'.\n#'                    Default method is 'bobyqa'\n#'\n#'@param warping_opt numeric vector. The parameters depend on the warping_method chosen.\n#'                   If warping_method ='affine' warping_opt <- c( max_dilation , max_shift). \\cr\n#'                   If warping_method <- 'dilation' warping_opt <- c(max_dilation).\\cr\n#'                   If warping_method <- 'shift'  warping_opt <- c(max_shift).\\cr\n#'                   If warping_method <- 'noalign' warping_opt <- as.numeric().\\cr\n#'                   Default value is warping_opt<-c(0.15,0.15). \\cr\n#'\n#'@param center_opt numeric vector. The parameters depend on the center_method chosen.\n#'                  If center_method ='mean' center_opt <- c(span, delta). \\cr\n#'                  If center_method ='medoid' center_opt <- as.numeric(). \\cr\n#'                  If center_method ='pseudomedoid' center_opt <- as.numeric(). \\cr\n#'                  Default value is center_opt<-c(0.01,0.1). \\cr\n#'\n#'@param out_opt numeric vector. The parameters to set are (n_out , tollerance, max_iteration).\n#'               n_out is the size of the grid where the centers will be computed.\n#'               tollerance is a stop condition parameter.\n#'               max_iterationa is a stop condition parameter.\n#'               The defaut value is out_opt <- c(100 , 0.001 , 100).\n#'\n#'@param fence boolean: if fence=TRUE a control is activated at the end of each iteration.\n#'             The aim of the control is to avoid warping outliers with respect to their\n#'             computed distributions. If fence=TRUE the running time can increase\n#'             considerably. Default value of fence is FALSE.\n#'\n#'@param check_total_similarity boolean: if check.total.similarity=TRUE at each iteration\n#'                              the algorithm checks if the total similarity is improving\n#'                              and stops if it's not true. In this case the results\n#'                              obtained in the penultimate iteration are returned.\n#'                               Defaultvalue is TRUE.\n#'\n#'@param show_iter boolean: if show.iter=TRUE kmap shows the current iteration of the\n#'                 algorithm. Default value is TRUE.\n#'\n#'@param comp_original_center boolean: if comp_original_center=TRUE the initial center\n#'                            with relative dissimilarities is computed otherwise this\n#'                            step is skipped.It can by computationally expensive.\n#'                             Default value is FALSE.\n#'\n#'@param par_opt  numeric vector: Parallel options. The parameters to set are (num_threads, parallel_version)\n#'                parallel_version  available are 0 and 1 :  0 is a trivial parallelization in which each\n#'                thread compute the center of a cluster; 1 is a more efficient parallelization in which\n#'                all the threads compute the centers sequentially (available only with center_method = 'medoid').\n#'\n#'@return The function output is a list containing the following elements:\n#'\n#' \\item{x}{ as input.}\n#' \\item{y}{ as input. }\n#' \\item{seeds}{ vector with the indeces used in the algorithm.}\n#' \\item{warping.method}{ as input.}\n#' \\item{similarity.method}{ as input. }\n#' \\item{center.method }{ as input. }\n#' \\item{iterations }{scalar: total number of iterations performed by kma function.}\n#' \\item{n.clust }{ as input. }\n#' \\item{x.center.orig }{numeric vector \\emph{n_out}: abscissa of the center computed if \\emph{comp_original_center}=TRUE.}\n#' \\item{y.center.orig }{numeric vector \\emph{n_out} or matrix \\emph{n_out} X \\emph{n_dim}: value of the center computed if \\emph{comp_original_center}=TRUE.}\n#' \\item{similarity.origin}{numeric vector \\emph{n_obs} dissimilarity,similarity or distance of the original center respect the obserbations computed if \\emph{comp_original_center}=TRUE.}\n#' \\item{x.final }{matrix [n.func X grid.size]: aligned abscissas.}\n#' \\item{n.clust.final }{ scalar: final number of clusters. Note that n.clust.final may differ from initial number of clusters (i.e.,from n.clust) if some clusters are found to be empty.}\n#' \\item{x.centers.final }{matrix [n.clust.final X grid.size]: abscissas of the final function centers.}\n#' \\item{y.centers.final }{matrix [n.clust.final X n.out] or array [n.clust.final X n.out x n_dim] , contain the evaluations of the final functions centers.}\n#' \\item{templates_vec }{list iteration : each element of the list contain centers of that iteration.}\n#' \\item{x_out_vec }{list iteration : each element of the list contain the abscissa of the centers of that iteration.}\n#' \\item{labels}{vector n_obs: cluster assignments.}\n#' \\item{similarity.final}{vector [n_obs]: similarities,dissimilarities or distance between each function and the center of the cluster the function is assigned to.}\n#' \\item{parameters.list}{list [iterations]: warping parameters at each iteration.}\n#' \\item{parameters}{matrix [n_par X n_obs]: warping parameters applied to the original abscissas x to obtain the aligned abscissas x.final.}\n#' \\item{timer}{vector: time of execution by step. }\n\n#  ------------------------------------------------------------------------\n\n\n\nkmap <- function(x, y, seeds= NULL, n_clust = 1,\n       warping_method ='affine', center_method ='mean',\n       similarity_method ='pearson', optim_method = 'bobyqa',\n       warping_opt=c(0.15,0.15), center_opt = c(0.01,0.1), out_opt = c(100 , 0.001 , 100),\n       fence = FALSE, check_total_similarity = TRUE,show_iter = TRUE,\n       comp_original_center=FALSE, par_opt=c(1,0))\n{\n\n  if(is.null(y))\n    stop(\"Provvide a valid function\")\n\n  if(length(dim(y))==2){\n    y<-array(y,c(dim(y)[1],dim(y)[2],1))\n  }\n\n  if(is.vector(x))\n   x <- t(replicate(dim(y)[1],x,1))\n\n  if(is.null(seeds)){\n    nseeds<-sample(0:(nrow(y)-1),n_clust)\n  }else{\n    nseeds<-(seeds-1)\n  }\n  if ((sum(nseeds<0)+sum(nseeds>=nrow(y)))!=0 )\n    stop(\"seeds indexes have to be in observations range\")\n\n  out<-.Call('_fdakmapp_kmap', PACKAGE = 'fdakmapp', x, y, nseeds, n_clust, warping_method, center_method, similarity_method, optim_method, warping_opt, center_opt, out_opt, fence, check_total_similarity, show_iter, comp_original_center,par_opt)\n\n  ## gestione timer  ################################################\n  time<-diff(round(out$timer/1000000000,4))\n  t<-data.frame(0,0,0,0,0,0)\n  names(t)<-c(\"start\",\"warping\",\"fece/norm\",\"templates\",\"output\",\"total\")\n  rownames(t)<-c(\"sec\")\n  t[1]<-time[1]\n  for(i in 0:(out$iterations-1)){\n    t[2]=t[2]+time[2+(i*3)]\n    t[3]=t[3]+time[3+(i*3)]\n    t[4]=t[4]+time[4+(i*3)]\n  }\n  t[5]=time[out$iterations*3+2]\n  t[6]=out$timer[length(out$timer)]/1000000000\n  out$timer<-t\n    #######################################################################\n\n  out<-c(x=list(x),y=list(y), seeds=list(nseeds), warping.method = list(warping_method),\n         similarity.method = list(similarity_method),center.method = list(center_method),out)\n\n}\n",
    "created" : 1510405645733.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "30795980",
    "id" : "110ACA75",
    "lastKnownWriteTime" : 1510405042,
    "last_content_update" : 1510405042,
    "path" : "~/Desktop/Fdakmaplus/fdakmapp/R/kmap.R",
    "project_path" : "R/kmap.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}