% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kmap.R
\name{kmap}
\alias{kmap}
\title{Clustering and alignment of functional data}
\usage{
res<-kmap(  x, y,  y1, n_clust,warping_method, center_method,similarity_method,
optim_method, seeds, span, delta, d_max, s_max, n_out, toll, fence,
iter_max,show_iter, check_total_similarity)
}
\arguments{
\item{x}{A matrix \emph{n.func} X \emph{grid.size} or vector \emph{grid.size}:
the abscissa values where each function is evaluated. \emph{n.func}: number
of functions in the dataset. \emph{grid.size}: maximal number of abscissa values
 where each function is evaluated. The abscissa points may be unevenly spaced and
 they may differ from function to function. \code{x} can also be a vector of length
  \emph{grid.size}. In this case, \code{x} will be used as abscissa grid for all
  functions.Furthermore if the grid's size differs from one function to another the
  matrix must be completed with NA values.The parameter \code{y} must be
  provided.}

\item{y}{A matrix \emph{n.func} X \emph{grid.size} or array \emph{n.func} X \emph{grid.size}
X \emph{d}: evaluations of the set of original functions on the abscissa grid
\code{x}. \emph{n.func}: number of functions in the dataset. \emph{grid.size}:
maximal number of abscissa values where each function is evaluated. \emph{d}:
(only if the sample is multidimensional) number of function components, i.e.
 each function is a \emph{d}-dimensional curve. The parameter \code{yx} must be
  provided.}

\item{seeds}{vector max(n.clust) or matrix nstart X n.clust: indexes of the functions
to be used as initial centers. If it is a matrix, each row contains the
 indexes of the initial centers of one of the nstart initializations.
 In the case where not all the values of seeds are provided, those not
 provided are randomly chosen among the n.func original functions.
 If seeds=NULL all the centers are randomly chosen. Default value of seeds
 is NULL.}

\item{n_clust}{scalar: required number of clusters. Default value is 1. Note that if
n.clust=1 kma performs only alignment without clustering.}

\item{warping_method}{character: type of alignment required. If warping.method='noalign'
kma performs only clustering (without alignment).
If warping.method='affine' kma performs alignment
(and possibly clustering) of functions using linear affine
transformation as warping functions, i.e., x.final = dilation*x + shift.
 If warping.method='shift' kma allows only shift, i.e.,
 x.final = x + shift. If warping.method='dilation' kma allows only
 dilation, i.e., x.final = dilation*x. Default value is 'affine'.}

\item{center_method}{character: type of clustering method to be used.
Possible choices are: 'mean' and 'medoid' and 'pseudomedoid'.
Default value is 'mean'.}

\item{similarity_method}{character: required similarity measure. Possible choices are:
'pearson','l2'. Default value is 'pearson'.
See (what to define?) for details.}

\item{optim_method}{character: optimization method chosen to find the best warping
functions at each iteration. Possible choices are: 'bobyqa'.
 See optim function for details.
 Default method is 'bobyqa'}

\item{warping_opt}{numeric vector. The parameters to set depend on the warping_method chosen.
If warping_method ='affine' warping_opt <- c( max_dilation , max_shift).
If warping_method <- 'dilation' warping_opt <- c(max_dilation).
If warping_method <- 'shift'  warping_opt <- c(max_shift).
If warping_method <- 'noalign' warping_opt <- as.numeric().}

\item{center_opt}{numeric vector. The parameters to set depend on the center_method chosen.
If center_method ='mean' center_opt <- c( span, delta).
If center_method ='medoid' center_opt <- as.numeric().
If center_method ='pseudomedoid' center_opt <- as.numeric().}

\item{out_opt}{numeric vector. The parameters to set are (n_out , tollerance, max_iteration).
n_out is the size of the grid where the centers will be computed.
tollerance is a stop condition parameter.
max_iterationa is a stop condition parameter.}

\item{fence}{boolean: if fence=TRUE a control is activated at the end of each iteration.
The aim of the control is to avoid warping outliers with respect
 to their computed distributions. If fence=TRUE the running time can increase
  considerably. Default value of fence is FALSE.}

\item{check_total_similarity}{boolean: if check.total.similarity=TRUE at each iteration
the algorithm checks if there is a decrease of the total
similarity and stops. In the affermative case the result
obtained in the penultimate iteration is returned.
 Defaultvalue is TRUE.}

\item{show_iter}{boolean: if show.iter=TRUE kmap shows the current iteration of the
algorithm. Default value is TRUE.}

\item{comp_original_center}{boolean: if comp_original_center=TRUE the initial center with relative dissimilarities
is computed otherwise this step is skipped. Default value is FALSE.}

\item{par_opt}{numeric vector. Parallel options. The parameters to set are (num_threads,parallel_version)
parallel_version  available are 0 and 1 :  0 is a trivial parallelization in which each
thread compute the center of a cluster; 1 is a more efficient parallelization in which
all the threads compute the centers sequentially(available only with center_method = 'medoid').}
}
\value{
The function output is a list containing the following elements:

\item{ x }{ as input.}
\item{ y }{ as input. }
\item{seeds}{ vector with the indeces used in the algorithm.}

\item{ warping.method }{ as input.}
\item{ similarity.method }{ as input. }
\item{ center.method }{ as input. }
\item{ iterations }{scalar: total number of iterations performed by kma function.}
\item{ n.clust }{ as input. }
\item{ x.center.orig }{numeric vector \emph{n_out}: abscissa of the center computed if \emph{comp_original_center}=TRUE.}
\item{ y.center.orig }{numeric vector \emph{n_out} or matrix \emph{n_out} X \emph{n_dim}: value of the center computed if \emph{comp_original_center}=TRUE.}
\item{similarity.origin}{numeric vector \emph{n_obs} dissimilarity,similarity or distance of the original center respect the obserbations computed if \emph{comp_original_center}=TRUE.}
\item{ x.final }{matrix n.func X grid.size: aligned abscissas.}
\item{ n.clust.final }{ scalar: final number of clusters. Note that n.clust.final may differ from initial number of clusters (i.e.,from n.clust) if some clusters are found to be empty.}
\item{ x.centers.final }{matrix n.clust.final X grid.size: abscissas of the final function centers.}
\item{ y.centers.final }{matrix n.clust.final X n.out or array n.clust.final X n.out x n_dim , contain the evaluations of the final functions centers.}
\item{ templates_vec }{list iteration : each element of the list contain centers of that iteration.}
\item{ x_out_vec }{list iteration : each element of the list contain the abscissa of the centers of that iteration.}
\item{ labels }{vector n_obs: cluster assignments.}
\item{ similarity.final }{vector n_obs: similarities,dissimilarities or distance between each function and the center of the cluster the function is assigned to.}
\item{parameters.list}{list iterations: warping parameters at each iteration.}
\item{parameters}{matrix n_par X n_obs: warping parameters applied to the original abscissas x to obtain the aligned abscissas x.final.}
\item{timer}{vector : time of execution. }
}
\description{
kmap jointly performs clustering and alignment of a functional dataset
(multidimensional or unidimensional functions). To run kmap function with different
numbers of clusters and/or different alignment methods see
}
