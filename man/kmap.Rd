% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kmap.R
\name{kmap}
\alias{kmap}
\title{K-mean algorithm for clustering and alignment of functional data}
\usage{
res<-kmap(  x, y,  y1, n_clust,warping_method, center_method,similarity_method,
optim_method, seeds, span, delta, d_max, s_max, n_out, toll, fence,
iter_max,show_iter, check_total_similarity)
}
\arguments{
\item{x}{numeric matrix [\emph{n.func} X \emph{grid.size}] or vector [\emph{grid.size}]:
the abscissa values where each function is evaluated. \emph{n.func}: number
of functions in the dataset. \emph{grid.size}: maximal number of abscissa values
where each function is evaluated. The abscissa points may be unevenly spaced and
they may differ from function to function. \code{x} can also be a vector of length
\emph{grid.size}. In this case, \code{x} will be used as abscissa grid for all
functions.Furthermore if the grid's size differs from one function to another the
matrix must be completed with NA values.The parameter \code{x} must be
provided.}

\item{y}{numeric matrix [\emph{n.func} X \emph{grid.size}] or array [\emph{n.func} X \emph{grid.size}
X \emph{d}]: evaluations of the set of original functions on the abscissa grid
\code{x}. \emph{n.func}: number of functions in the dataset. \emph{grid.size}:
maximal number of abscissa values where each function is evaluated. \emph{d}:
(only if the sample is multidimensional) number of function components, i.e.
 each function is a \emph{d}-dimensional curve. The parameter \code{y} must be
  provided.}

\item{seeds}{numeric vector [n.clust] indexes of the functions to be used as initial centers.
In the case where the values of seeds are not provided, they are randomly
 chosen among the \emph{n.func} original functions.If seeds=NULL all the
 centers are randomly chosen. Default value of seeds is NULL.}

\item{n_clust}{scalar: required number of clusters. Default value is 1. Note that if
n.clust=1 kma performs only alignment without clustering.}

\item{warping_method}{character: type of alignment required. The implemented options
are: "affine", "dialation", "shift" and "noalign". If
warping.method='noalign' kma performs only clustering (without
 alignment). If warping.method='affine' kma performs alignment
(and possibly clustering) of functions using linear affine
transformation as warping functions, i.e., x.final = dilation*x + shift.
 If warping.method='shift' kma allows only shift, i.e.,
 x.final = x + shift. If warping.method='dilation' kma allows only
 dilation, i.e., x.final = dilation*x. Default value is 'affine'.}

\item{center_method}{character: type of clustering method to be used.
Possible choices are: 'mean','medoid' and 'pseudomedoid'.
Default value is 'mean'.}

\item{similarity_method}{character: required similarity measure. Possible choices are:
'pearson','l2'. Default value is 'pearson'.}

\item{optim_method}{character: optimization method chosen to solve the minimization
problems at each iteration. Possible choices are: 'bobyqa'.
Default method is 'bobyqa'}

\item{warping_opt}{numeric vector. The parameters depend on the warping_method chosen.
If warping_method ='affine' warping_opt <- c( max_dilation , max_shift). \cr
If warping_method <- 'dilation' warping_opt <- c(max_dilation).\cr
If warping_method <- 'shift'  warping_opt <- c(max_shift).\cr
If warping_method <- 'noalign' warping_opt <- as.numeric().\cr
Default value is warping_opt<-c(0.15,0.15). \cr}

\item{center_opt}{numeric vector. The parameters depend on the center_method chosen.
If center_method ='mean' center_opt <- c(span, delta). \cr
If center_method ='medoid' center_opt <- as.numeric(). \cr
If center_method ='pseudomedoid' center_opt <- as.numeric(). \cr
Default value is center_opt<-c(0.01,0.1). \cr}

\item{out_opt}{numeric vector. The parameters to set are (n_out , tollerance, max_iteration).
n_out is the size of the grid where the centers will be computed.
tollerance is a stop condition parameter.
max_iterationa is a stop condition parameter.
The defaut value is out_opt <- c(100 , 0.001 , 100).}

\item{fence}{boolean: if fence=TRUE a control is activated at the end of each iteration.
The aim of the control is to avoid warping outliers with respect to their
computed distributions. If fence=TRUE the running time can increase
considerably. Default value of fence is FALSE.}

\item{check_total_similarity}{boolean: if check.total.similarity=TRUE at each iteration
the algorithm checks if the total similarity is improving
and stops if it's not true. In this case the results
obtained in the penultimate iteration are returned.
 Defaultvalue is TRUE.}

\item{show_iter}{boolean: if show.iter=TRUE kmap shows the current iteration of the
algorithm. Default value is TRUE.}

\item{comp_original_center}{boolean: if comp_original_center=TRUE the initial center
with relative dissimilarities is computed otherwise this
step is skipped.It can by computationally expensive.
 Default value is FALSE.}

\item{par_opt}{numeric vector: Parallel options. The parameters to set are (num_threads, parallel_version)
parallel_version  available are 0 and 1 :  0 is a trivial parallelization in which each
thread compute the center of a cluster; 1 is a more efficient parallelization in which
all the threads compute the centers sequentially (available only with center_method = 'medoid').}
}
\value{
The function output is a list containing the following elements:

\item{x}{ as input.}
\item{y}{ as input. }
\item{seeds}{ vector with the indeces used in the algorithm.}
\item{warping.method}{ as input.}
\item{similarity.method}{ as input. }
\item{center.method }{ as input. }
\item{iterations }{scalar: total number of iterations performed by kma function.}
\item{n.clust }{ as input. }
\item{x.center.orig }{numeric vector \emph{n_out}: abscissa of the center computed if \emph{comp_original_center}=TRUE.}
\item{y.center.orig }{numeric vector \emph{n_out} or matrix \emph{n_out} X \emph{n_dim}: value of the center computed if \emph{comp_original_center}=TRUE.}
\item{similarity.origin}{numeric vector \emph{n_obs} dissimilarity,similarity or distance of the original center respect the obserbations computed if \emph{comp_original_center}=TRUE.}
\item{x.final }{matrix [n.func X grid.size]: aligned abscissas.}
\item{n.clust.final }{ scalar: final number of clusters. Note that n.clust.final may differ from initial number of clusters (i.e.,from n.clust) if some clusters are found to be empty.}
\item{x.centers.final }{matrix [n.clust.final X grid.size]: abscissas of the final function centers.}
\item{y.centers.final }{matrix [n.clust.final X n.out] or array [n.clust.final X n.out x n_dim] , contain the evaluations of the final functions centers.}
\item{templates_vec }{list iteration : each element of the list contain centers of that iteration.}
\item{x_out_vec }{list iteration : each element of the list contain the abscissa of the centers of that iteration.}
\item{labels}{vector n_obs: cluster assignments.}
\item{similarity.final}{vector [n_obs]: similarities,dissimilarities or distance between each function and the center of the cluster the function is assigned to.}
\item{parameters.list}{list [iterations]: warping parameters at each iteration.}
\item{parameters}{matrix [n_par X n_obs]: warping parameters applied to the original abscissas x to obtain the aligned abscissas x.final.}
\item{timer}{vector: time of execution by step. }
}
\description{
kmap jointly performs clustering and alignment of a functional dataset
(multidimensional or unidimensional functions). To run kmap function with different
numbers of clusters and/or different alignment methods see the input options.
}
